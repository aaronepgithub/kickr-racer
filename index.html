<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Bluetooth Wahoo Kickr Racer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .race-dot {
            transition: left 0.5s linear, top 0.5s linear;
        }
        .countdown-timer {
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">

    <div id="app" class="min-h-screen flex flex-col items-center justify-center p-4">
        <div class="w-full max-w-4xl mx-auto bg-gray-800 rounded-2xl shadow-lg p-6 space-y-6">

            <!-- Header -->
            <div class="text-center">
                <h1 class="text-3xl font-bold text-cyan-400">Kickr GPX Racer</h1>
                <p class="text-gray-400">Create a race, share the link, and ride with friends.</p>
            </div>
            
            <!-- Race Countdown Timer -->
            <div id="countdown-section" class="hidden text-center bg-gray-700 p-4 rounded-lg">
                <p class="font-semibold mb-2 text-lg">Race Starts In:</p>
                <p id="countdown-timer" class="text-5xl font-bold text-yellow-400 countdown-timer">00:00</p>
            </div>

            <!-- Status & Connection -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                <div id="bluetooth-status" class="bg-gray-700 p-4 rounded-lg">
                    <p class="font-semibold">Trainer Status</p>
                    <p class="text-red-400">Disconnected</p>
                </div>
                <div id="race-status" class="bg-gray-700 p-4 rounded-lg">
                    <p class="font-semibold">Race Status</p>
                    <p class="text-gray-400">Not Started</p>
                </div>
                <div id="user-id-display" class="bg-gray-700 p-4 rounded-lg">
                    <p class="font-semibold">Your Racer ID</p>
                    <p class="text-yellow-400 text-xs break-all">Initializing...</p>
                </div>
            </div>

            <!-- Debug Panel (shows raw bytes + parsed power offset) -->
            <div id="debug-panel" class="hidden mt-4 bg-gray-800 p-3 rounded-lg text-sm">
                <div class="flex justify-between items-center mb-2">
                    <p class="font-semibold text-cyan-300">Bluetooth Debug</p>
                    <div class="flex items-center space-x-2">
                        <label class="text-gray-400">Offset</label>
                        <input id="power-offset-input" type="number" min="0" value="2" class="bg-gray-700 text-white w-20 p-1 rounded text-center">
                        <button id="toggle-debug-btn" class="bg-gray-600 hover:bg-gray-500 text-white py-1 px-2 rounded">Hide</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 gap-1 text-left">
                    <div><span class="text-gray-400">Last raw bytes:</span> <code id="debug-raw-hex" class="text-yellow-300">—</code></div>
                    <div><span class="text-gray-400">Parsed power:</span> <span id="debug-parsed-power" class="text-yellow-300">—</span></div>
                    <div><span class="text-gray-400">Used offset:</span> <span id="debug-used-offset" class="text-yellow-300">2</span></div>
                </div>
            </div>

            <!-- Pre-Race Controls -->
            <div id="pre-race-controls" class="space-y-4">
                <div class="flex flex-wrap justify-center items-center gap-4">
                    <button id="connect-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        Connect to Trainer
                    </button>
                     <div class="flex items-center space-x-2">
                         <label for="weight-input" class="font-semibold">Your Weight:</label>
                         <input type="number" id="weight-input" class="bg-gray-700 text-white w-24 p-2 rounded-lg text-center" value="165">
                         <span class="text-gray-400">lbs</span>
                    </div>
                </div>
                 <div class="flex flex-wrap justify-center items-center gap-4">
                    <div class="flex items-center space-x-2">
                         <input type="file" id="gpx-upload" accept=".gpx" class="hidden"/>
                         <label for="gpx-upload" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors">
                             Upload GPX Route
                         </label>
                         <span id="gpx-file-name" class="text-gray-400">No file chosen</span>
                    </div>
                    <button id="create-race-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                        Create Race
                    </button>
                </div>
            </div>
            
             <!-- Race Creator: Start Timer Controls -->
            <div id="start-timer-controls" class="hidden text-center bg-gray-700 p-4 rounded-lg space-y-2">
                 <p class="font-semibold">Set Race Start Time:</p>
                 <div class="flex justify-center gap-2">
                     <button data-time="1" class="start-time-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">1 min</button>
                     <button data-time="5" class="start-time-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">5 mins</button>
                     <button data-time="10" class="start-time-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">10 mins</button>
                 </div>
            </div>

            <!-- Share Link Modal -->
            <div id="share-link-section" class="hidden text-center bg-gray-700 p-4 rounded-lg">
                <p class="font-semibold mb-2">Race Created! Share this link:</p>
                <input id="share-link-input" type="text" class="w-full bg-gray-800 text-cyan-300 p-2 rounded border border-gray-600 text-center" readonly>
                <button id="copy-link-btn" class="mt-2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg text-sm">Copy</button>
            </div>

            <!-- Race Display -->
            <div id="race-display" class="space-y-4 pt-4 border-t border-gray-700">
                <!-- Player Data -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <p class="text-sm text-gray-400">Power</p>
                        <p id="power-display" class="text-2xl font-bold">0 W</p>
                    </div>
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <p class="text-sm text-gray-400">Speed</p>
                        <p id="speed-display" class="text-2xl font-bold">0.0 mph</p>
                    </div>
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <p class="text-sm text-gray-400">Distance</p>
                        <p id="distance-display" class="text-2xl font-bold">0.00 mi</p>
                    </div>
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <p class="text-sm text-gray-400">Gradient</p>
                        <p id="gradient-display" class="text-2xl font-bold">0.0 %</p>
                    </div>
                     <div class="bg-gray-700 p-3 rounded-lg col-span-2 md:col-span-4">
                        <p class="text-sm text-gray-400">Total Race Distance</p>
                        <p id="total-distance-display" class="text-2xl font-bold">0.00 mi</p>
                    </div>
                </div>

                <!-- Course Profile -->
                <div>
                    <h3 class="font-semibold mb-2 text-center">Course Profile</h3>
                    <div id="course-profile-container" class="relative w-full h-40 bg-gray-900 rounded-lg overflow-hidden">
                        <canvas id="course-profile-canvas" class="w-full h-full"></canvas>
                        <!-- Racer dots will be dynamically added here -->
                    </div>
                </div>

                <!-- Leaderboard -->
                <div>
                    <h3 class="font-semibold mb-2 text-center">Racers</h3>
                    <div id="leaderboard" class="space-y-2">
                        <!-- Racer entries will be dynamically added here -->
                        <div class="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                            <p>Waiting for racers to join...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Firebase SDK -->
    <script type="module">
        // --- IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDoc, updateDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONFIG ---
         const firebaseConfig = {
            apiKey: "AIzaSyCY-RqfO0XUcRkZ7OBLDtMm-e-jVJyLrQ0",
            authDomain: "kickr-racer.firebaseapp.com",
            projectId: "kickr-racer",
            storageBucket: "kickr-racer.appspot.com",
            messagingSenderId: "433608140491",
            appId: "1:433608140491:web:d5d736f7d6cfdeaf7edd4e"
        };
        const appId = 'default-app-id';

        // --- APPLICATION STATE ---
        const state = {
            userId: null,
            raceId: null,
            gpxData: null,
            racers: {},
            totalDistance: 0, // In miles
            distanceCovered: 0, // In miles
            speed: 0, // In mph
            power: 0, // In watts
            gradient: 0,
            riderWeightLbs: 165,
            raceStartTime: null, // Timestamp
            raceStarted: false,
            countdownInterval: null,
            trainer: {
                device: null,
                controlCharacteristic: null,
                dataCharacteristic: null,
                connected: false,
                powerOffset: 2, // configurable offset to read instantaneous power (default 2)
            },
            raceUnsubscribe: null,
            raceDocUnsubscribe: null,
        };
        
        // --- DOM ELEMENTS ---
        const DOMElements = {
            connectBtn: document.getElementById('connect-btn'),
            weightInput: document.getElementById('weight-input'),
            gpxUpload: document.getElementById('gpx-upload'),
            gpxFileName: document.getElementById('gpx-file-name'),
            createRaceBtn: document.getElementById('create-race-btn'),
            bluetoothStatus: document.getElementById('bluetooth-status').querySelector('p:last-child'),
            raceStatus: document.getElementById('race-status').querySelector('p:last-child'),
            userIdDisplay: document.getElementById('user-id-display').querySelector('p:last-child'),
            powerDisplay: document.getElementById('power-display'),
            speedDisplay: document.getElementById('speed-display'),
            distanceDisplay: document.getElementById('distance-display'),
            gradientDisplay: document.getElementById('gradient-display'),
            totalDistanceDisplay: document.getElementById('total-distance-display'),
            leaderboard: document.getElementById('leaderboard'),
            courseProfileContainer: document.getElementById('course-profile-container'),
            courseProfileCanvas: document.getElementById('course-profile-canvas'),
            shareLinkSection: document.getElementById('share-link-section'),
            shareLinkInput: document.getElementById('share-link-input'),
            copyLinkBtn: document.getElementById('copy-link-btn'),
            preRaceControls: document.getElementById('pre-race-controls'),
            countdownSection: document.getElementById('countdown-section'),
            countdownTimer: document.getElementById('countdown-timer'),
            startTimerControls: document.getElementById('start-timer-controls'),
            // Debug elements
            debugPanel: document.getElementById('debug-panel'),
            debugRawHex: document.getElementById('debug-raw-hex'),
            debugParsedPower: document.getElementById('debug-parsed-power'),
            debugUsedOffset: document.getElementById('debug-used-offset'),
            powerOffsetInput: document.getElementById('power-offset-input'),
            toggleDebugBtn: document.getElementById('toggle-debug-btn'),
        };

        // --- FIREBASE MODULE ---
        const FirebaseController = {
            db: null,
            auth: null,
            init() {
                try {
                    const app = initializeApp(firebaseConfig);
                    this.db = getFirestore(app);
                    this.auth = getAuth(app);
                    setLogLevel('debug');
                    this.authenticate();
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    DOMElements.raceStatus.textContent = "Firebase Error";
                    DOMElements.raceStatus.className = "text-red-500 font-bold";
                }
            },
            authenticate() {
                onAuthStateChanged(this.auth, async (user) => {
                    if (user) {
                        state.userId = user.uid;
                        DOMElements.userIdDisplay.textContent = state.userId;
                        console.log("Authenticated with user ID:", state.userId);
                        
                        // Check if joining an existing race from URL
                        const urlParams = new URLSearchParams(window.location.search);
                        const raceIdFromUrl = urlParams.get('raceId');
                        if (raceIdFromUrl) {
                            this.joinRace(raceIdFromUrl);
                        }

                    } else {
                       try {
                           await signInAnonymously(this.auth);
                           console.log("Signed in anonymously.");
                       } catch (error) {
                           console.error("Anonymous sign-in failed:", error);
                       }
                    }
                });
            },
            async createRace() {
                if (!this.db || !state.gpxData) return;
                try {
                    const startTime = new Date(Date.now() + 5 * 1000); // Default 1 minute from now
                    const docRef = await addDoc(collection(this.db, `artifacts/${appId}/public/data/races`), {
                        gpx: JSON.stringify(state.gpxData),
                        createdAt: serverTimestamp(),
                        totalDistance: state.totalDistance,
                        creatorId: state.userId,
                        startTime: startTime,
                    });
                    state.raceId = docRef.id;
                    this.joinRace(state.raceId);
                    UIController.showShareLink(state.raceId);
                } catch (e) {
                    console.error("Error creating race: ", e);
                }
            },
            async joinRace(raceId) {
                if (!this.db || !state.userId) return;
                state.raceId = raceId;
                
                const raceDocRef = doc(this.db, `artifacts/${appId}/public/data/races`, raceId);
                
                // Listen for changes to the main race document (like startTime)
                if (state.raceDocUnsubscribe) state.raceDocUnsubscribe();
                state.raceDocUnsubscribe = onSnapshot(raceDocRef, (docSnap) => {
                     if (docSnap.exists()) {
                        const raceData = docSnap.data();
                        
                        if (!state.gpxData) { // Only load GPX once
                           state.gpxData = JSON.parse(raceData.gpx);
                           state.totalDistance = raceData.totalDistance;
                           UIController.updateTotalDistance();
                           UIController.drawCourseProfile();
                        }
                        
                        state.raceStartTime = raceData.startTime.toDate();
                        UIController.startCountdown();

                        DOMElements.raceStatus.textContent = 'Race Joined';
                        DOMElements.raceStatus.className = 'text-green-400';
                        DOMElements.preRaceControls.classList.add('hidden');
                        
                        if (raceData.creatorId === state.userId) {
                            DOMElements.startTimerControls.classList.remove('hidden');
                        }

                        // Add self to the racers subcollection so others can see you
                        this.updatePlayerState();
                        // Listen for other racers
                        this.listenForRacers();

                    } else {
                        console.error("Race not found!");
                        DOMElements.raceStatus.textContent = "Race Not Found";
                        DOMElements.raceStatus.className = "text-red-500";
                    }
                });
            },
            async updateRaceStartTime(minutes) {
                if (!this.db || !state.raceId) return;
                const newStartTime = new Date(Date.now() + minutes * 60 * 1000);
                const raceDocRef = doc(this.db, `artifacts/${appId}/public/data/races`, state.raceId);
                await updateDoc(raceDocRef, { startTime: newStartTime });
            },
            updatePlayerState() {
                if (!this.db || !state.userId || !state.raceId) return;
                const racerDocRef = doc(this.db, `artifacts/${appId}/public/data/races`, state.raceId, "racers", state.userId);
                const data = {
                    id: state.userId,
                    distance: state.distanceCovered,
                    speed: state.speed,
                    lastUpdate: serverTimestamp(),
                };
                setDoc(racerDocRef, data, { merge: true });
            },
            listenForRacers() {
                if (state.raceUnsubscribe) state.raceUnsubscribe(); // Unsubscribe from previous listener
                const racersColRef = collection(this.db, `artifacts/${appId}/public/data/races`, state.raceId, "racers");
                state.raceUnsubscribe = onSnapshot(racersColRef, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        const racerData = change.doc.data();
                        state.racers[racerData.id] = racerData;
                    });
                    UIController.updateLeaderboard();
                    UIController.updateRacerDots();
                });
            }
        };

        // --- BLUETOOTH MODULE ---
        const BluetoothController = {
            async connect() {
                if (!navigator.bluetooth) {
                    console.error('Web Bluetooth API not available in this browser.');
                    DOMElements.bluetoothStatus.textContent = 'Bluetooth Not Supported';
                    DOMElements.bluetoothStatus.className = 'text-red-400';
                    return;
                }

                try {
                    console.log('Requesting Bluetooth device (Fitness Machine Service)...');

                    const device = await navigator.bluetooth.requestDevice({
                        filters: [{ services: [0x1826] }], // Fitness Machine Service (0x1826)
                        optionalServices: [0x1826] // ensure we can access characteristics
                    });

                    state.trainer.device = device;
                    device.addEventListener('gattserverdisconnected', this.onDisconnect.bind(this));

                    DOMElements.connectBtn.disabled = true;
                    DOMElements.connectBtn.textContent = 'Connecting...';

                    const server = await device.gatt.connect();
                    console.log('GATT connected:', server);

                    const service = await server.getPrimaryService(0x1826);
                    console.log('Fitness Machine service obtained:', service);

                    // Indoor Bike Data (0x2AD2) and Fitness Machine Control Point (0x2AD9)
                    state.trainer.dataCharacteristic = await service.getCharacteristic(0x2AD2);
                    state.trainer.controlCharacteristic = await service.getCharacteristic(0x2AD9).catch(() => {
                        console.warn('Control Point not available (expected on some trainers).');
                        return null;
                    });

                    await state.trainer.dataCharacteristic.startNotifications();
                    state.trainer.dataCharacteristic.addEventListener('characteristicvaluechanged', this.handleData.bind(this));

                    state.trainer.connected = true;
                    DOMElements.bluetoothStatus.textContent = 'Connected';
                    DOMElements.bluetoothStatus.className = 'text-green-400';
                    DOMElements.connectBtn.textContent = 'Connected';
                    DOMElements.connectBtn.disabled = true;

                    console.log('Notifications started for Indoor Bike Data.');

                } catch (error) {
                    console.error('Bluetooth connection failed:', error);
                    DOMElements.bluetoothStatus.textContent = 'Connection Failed';
                    DOMElements.bluetoothStatus.className = 'text-red-400';
                    DOMElements.connectBtn.disabled = false;
                    DOMElements.connectBtn.textContent = 'Connect to Trainer';
                }
            },
            onDisconnect() {
                state.trainer.connected = false;
                state.trainer.device = null;
                DOMElements.bluetoothStatus.textContent = 'Disconnected';
                DOMElements.bluetoothStatus.className = 'text-red-400';
                DOMElements.connectBtn.disabled = false;
                DOMElements.connectBtn.textContent = 'Connect to Trainer';
                console.log('Trainer disconnected.');
            },
            handleData(event) {
                try {
                    const value = event.target.value; // DataView
                    const byteLen = value.byteLength || value.buffer?.byteLength || 0;
                    const raw = new Uint8Array(value.buffer, value.byteOffset || 0, byteLen);
                    const hex = Array.from(raw).map(b => b.toString(16).padStart(2,'0')).join(' ');
                    console.debug('Indoor Bike Data raw bytes:', hex);

                    // Update debug UI raw hex
                    if (DOMElements.debugRawHex) DOMElements.debugRawHex.textContent = hex;

                    if (byteLen < 4) {
                        console.warn('Notification too short to parse.');
                        return;
                    }

                    const flags = value.getUint16(0, true);

                    // 1) Try to parse using the spec-ish flag approach if instantaneous power bit is set (0x0004).
                    //    Compute offset by walking likely fields (speed/cadence) then read int16 there.
                    let foundPower = null;
                    let chosenOffset = state.trainer.powerOffset || 2;

                    if (flags & 0x0004) { // instantaneous power present (common mapping)
                        let offset = 2;
                        // If instantaneous speed present (bit 0) -> uint16 (2 bytes)
                        if (flags & 0x0001) offset += 2;
                        // If instantaneous cadence present (bit 1) -> uint8 (1 byte) in some implementations
                        if (flags & 0x0002) offset += 1;
                        // Additional optional fields exist in spec, but we handle the common ones above.
                        if (offset + 1 < byteLen) {
                            const v = value.getInt16(offset, true);
                            // basic sanity range check
                            if (v > -500 && v < 5000) {
                                foundPower = v;
                                chosenOffset = offset;
                                console.debug(`Power parsed using flags at offset ${offset}:`, v);
                            }
                        }
                    }

                    // 2) If not found, run a scored scan over even offsets and pick best candidate:
                    //    - prefer values close to recent state.power
                    //    - penalize extreme/unrealistic values
                    if (foundPower === null) {
                        let best = { offset: null, val: null, score: Infinity };
                        const prev = (typeof state.power === 'number') ? state.power : 0;

                        for (let i = 2; i + 1 < byteLen; i += 1) {
                            // read only 16-bit aligned values to avoid misaligned reads
                            if ((i % 2) !== 0) continue;
                            let v;
                            try { v = value.getInt16(i, true); } catch (e) { continue; }

                            // sanity filter: unrealistic extremes
                            if (v < -500 || v > 5000) continue;

                            // scoring: closeness to previous power
                            let score = Math.abs(v - prev);

                            // penalize extremely large values to avoid picking spurious high numbers
                            if (Math.abs(v) > 2500) score += 1000;
                            // small bonus if matches the previously preferred offset
                            if (i === (state.trainer.powerOffset || chosenOffset)) score *= 0.6;
                            // discourage exact zero (often not useful)
                            if (v === 0) score += 50;

                            if (score < best.score) {
                                best = { offset: i, val: v, score };
                            }
                        }

                        if (best.offset !== null) {
                            foundPower = best.val;
                            chosenOffset = best.offset;
                            console.debug(`Power chosen at offset ${chosenOffset} val ${foundPower} (score ${best.score})`);
                        }
                    }

                    if (foundPower !== null) {
                        state.power = foundPower;
                        state.trainer.powerOffset = chosenOffset;
                        UIController.updatePower();
                        if (DOMElements.debugParsedPower) DOMElements.debugParsedPower.textContent = String(foundPower);
                        if (DOMElements.debugUsedOffset) DOMElements.debugUsedOffset.textContent = String(chosenOffset);
                    } else {
                        console.warn('Unable to find valid power value in notification.');
                        if (DOMElements.debugParsedPower) DOMElements.debugParsedPower.textContent = 'n/a';
                    }

                } catch (err) {
                    console.error('Error parsing indoor bike data:', err);
                }
            },
            setGradient(gradient) {
                if (!state.trainer.connected || !state.trainer.controlCharacteristic) return;

                gradient = Math.max(-10, Math.min(20, gradient));
                const gradientValue = Math.round(gradient * 100);

                const command = new Uint8Array(5);
                const dataView = new DataView(command.buffer);
                dataView.setUint8(0, 0x11); // Set Simulation Parameters
                dataView.setInt16(1, 0, true); // Wind speed (0)
                dataView.setInt16(3, gradientValue, true); // Grade

                state.trainer.controlCharacteristic.writeValue(command)
                    .catch(err => console.error("Error setting gradient:", err));
            }
        };

        // --- GPX PARSING & PHYSICS MODULE ---
        const PhysicsController = {
             parseGPX(gpxString) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(gpxString, "text/xml");
                const points = [];
                const trkpts = xmlDoc.getElementsByTagName("trkpt");

                if (trkpts.length === 0) return null;

                for (let i = 0; i < trkpts.length; i++) {
                    const ele = trkpts[i].getElementsByTagName("ele")[0];
                    if (ele) {
                         points.push({
                            lat: parseFloat(trkpts[i].getAttribute("lat")),
                            lon: parseFloat(trkpts[i].getAttribute("lon")),
                            ele: parseFloat(ele.textContent)
                        });
                    }
                }
                
                const routeData = [];
                let totalDistanceKm = 0;

                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i+1];
                    const distanceKm = this.haversineDistance(p1, p2);
                    const elevationChangeM = p2.ele - p1.ele;
                    let gradient = (distanceKm > 0) ? (elevationChangeM / (distanceKm * 1000)) * 100 : 0;

                    routeData.push({
                        startDistance: totalDistanceKm * 0.621371, // convert to miles
                        distance: distanceKm * 0.621371, // convert to miles
                        gradient: isNaN(gradient) ? 0 : gradient,
                        ele: p1.ele,
                    });
                    totalDistanceKm += distanceKm;
                }
                 if (points.length > 0) {
                    routeData.push({
                        startDistance: totalDistanceKm * 0.621371,
                        distance: 0,
                        gradient: 0,
                        ele: points[points.length-1].ele
                    });
                }
                
                return { route: routeData, totalDistance: totalDistanceKm * 0.621371 };
            },
            haversineDistance(p1, p2) {
                const R = 6371; // km
                const dLat = (p2.lat - p1.lat) * Math.PI / 180;
                const dLon = (p2.lon - p1.lon) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                          Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                          Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            },
            // Solves for speed in m/s using an iterative approach
            calculateSpeedMps(power, gradient, weightLbs) {
                const riderWeightKg = weightLbs * 0.453592;
                const totalMass = riderWeightKg + 9; // Add bike weight
                const g = 9.81; // Gravity
                const Crr = 0.005; // Coefficient of rolling resistance
                const rho = 1.225; // Air density
                const CdA = 0.32; // Drag coefficient * frontal area
                
                const grade = gradient / 100;
                
                // Pre-calculate forces that don't depend on speed
                const forceGravity = totalMass * g * Math.sin(Math.atan(grade));
                const forceRolling = totalMass * g * Math.cos(Math.atan(grade)) * Crr;

                // Iteratively solve for velocity (v)
                // Power = (F_gravity + F_rolling) * v + (0.5 * rho * CdA) * v^3
                let v = 5; // Initial guess for speed in m/s
                for (let i = 0; i < 10; i++) { // 10 iterations is plenty for convergence
                    let v_squared = v * v;
                    let f_v = (forceGravity + forceRolling) * v + (0.5 * rho * CdA) * v_squared * v - power;
                    let f_prime_v = (forceGravity + forceRolling) + (1.5 * rho * CdA) * v_squared;
                    v = v - f_v / f_prime_v;
                    v = Math.max(0, v); // Speed cannot be negative
                }
                return v;
            }
        };

        // --- UI & GAME LOGIC CONTROLLER ---
        const UIController = {
            init() {
                DOMElements.connectBtn.addEventListener('click', () => BluetoothController.connect());
                DOMElements.gpxUpload.addEventListener('change', (event) => this.handleFileUpload(event));
                DOMElements.createRaceBtn.addEventListener('click', () => FirebaseController.createRace());
                DOMElements.copyLinkBtn.addEventListener('click', () => this.copyShareLink());
                DOMElements.weightInput.addEventListener('change', (e) => {
                    state.riderWeightLbs = parseFloat(e.target.value) || 165;
                });
                DOMElements.startTimerControls.addEventListener('click', (e) => {
                    if (e.target.classList.contains('start-time-btn')) {
                        const minutes = parseInt(e.target.dataset.time, 10);
                        FirebaseController.updateRaceStartTime(minutes);
                    }
                });
                window.addEventListener('resize', () => this.drawCourseProfile());

                // Debug controls
                if (DOMElements.powerOffsetInput) {
                    DOMElements.powerOffsetInput.value = state.trainer.powerOffset;
                    DOMElements.powerOffsetInput.addEventListener('change', (e) => {
                        const v = parseInt(e.target.value, 10);
                        if (!isNaN(v) && v >= 0) {
                            state.trainer.powerOffset = v;
                            if (DOMElements.debugUsedOffset) DOMElements.debugUsedOffset.textContent = String(v);
                            console.log('Set preferred power offset to', v);
                        }
                    });
                }
                if (DOMElements.toggleDebugBtn && DOMElements.debugPanel) {
                    DOMElements.toggleDebugBtn.addEventListener('click', () => {
                        const isHidden = DOMElements.debugPanel.classList.contains('hidden');
                        if (isHidden) {
                            DOMElements.debugPanel.classList.remove('hidden');
                            DOMElements.toggleDebugBtn.textContent = 'Hide';
                        } else {
                            DOMElements.debugPanel.classList.add('hidden');
                            DOMElements.toggleDebugBtn.textContent = 'Show';
                        }
                    });
                    // show panel by default when in development
                    DOMElements.debugPanel.classList.remove('hidden');
                }
            },
            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                DOMElements.gpxFileName.textContent = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const result = PhysicsController.parseGPX(e.target.result);
                    if (result) {
                        state.gpxData = result.route;
                        state.totalDistance = result.totalDistance;
                        this.updateTotalDistance();
                        this.drawCourseProfile();
                        DOMElements.createRaceBtn.disabled = false;
                    } else {
                        DOMElements.gpxFileName.textContent = "Invalid GPX file";
                    }
                };
                reader.readAsText(file);
            },
            updatePower() {
                 DOMElements.powerDisplay.textContent = `${state.power} W`;
            },
            updateSpeed() {
                DOMElements.speedDisplay.textContent = `${state.speed.toFixed(1)} mph`;
            },
            updateDistance() {
                 DOMElements.distanceDisplay.textContent = `${state.distanceCovered.toFixed(2)} mi`;
            },
            updateGradient() {
                DOMElements.gradientDisplay.textContent = `${state.gradient.toFixed(1)} %`;
            },
            updateTotalDistance() {
                DOMElements.totalDistanceDisplay.textContent = `${state.totalDistance.toFixed(2)} mi`;
            },
            startCountdown() {
                if (state.countdownInterval) clearInterval(state.countdownInterval);
                DOMElements.countdownSection.classList.remove('hidden');

                state.countdownInterval = setInterval(() => {
                    const now = new Date();
                    const diff = state.raceStartTime - now;

                    if (diff <= 0) {
                        DOMElements.countdownTimer.textContent = "GO!";
                        DOMElements.countdownSection.classList.add('bg-green-600');
                         DOMElements.countdownSection.classList.remove('bg-gray-700');
                        clearInterval(state.countdownInterval);
                        state.raceStarted = true;
                        DOMElements.raceStatus.textContent = 'Race in Progress';
                        return;
                    }

                    const minutes = Math.floor(diff / 1000 / 60);
                    const seconds = Math.floor(diff / 1000) % 60;
                    
                    DOMElements.countdownTimer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }, 1000);
            },
            updateLeaderboard() {
                DOMElements.leaderboard.innerHTML = '';
                const sortedRacers = Object.values(state.racers).sort((a, b) => b.distance - a.distance);

                if (sortedRacers.length === 0) {
                     DOMElements.leaderboard.innerHTML = `<div class="bg-gray-700 p-3 rounded-lg"><p>Waiting for racers to join...</p></div>`;
                     return;
                }

                sortedRacers.forEach(racer => {
                    const isSelf = racer.id === state.userId;
                    const racerEl = document.createElement('div');
                    racerEl.className = `p-3 rounded-lg flex justify-between items-center ${isSelf ? 'bg-cyan-800 border border-cyan-500' : 'bg-gray-700'}`;
                    racerEl.innerHTML = `
                        <p class="text-sm font-semibold truncate w-1/3">${isSelf ? 'You' : racer.id.substring(0,8)}...</p>
                        <p class="text-lg font-bold">${racer.distance.toFixed(2)} mi</p>
                        <p class="text-md">${racer.speed.toFixed(1)} mph</p>
                    `;
                    DOMElements.leaderboard.appendChild(racerEl);
                });
            },
            drawCourseProfile() {
                 if (!state.gpxData || state.gpxData.length === 0) return;
                const canvas = DOMElements.courseProfileCanvas;
                const ctx = canvas.getContext('2d');
                
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);

                const width = rect.width;
                const height = rect.height;

                const elevations = state.gpxData.map(p => p.ele);
                
                const maxEle = Math.max(...elevations);
                const minEle = Math.min(...elevations);
                const eleRange = maxEle - minEle === 0 ? 1 : maxEle - minEle;
                const padding = 20;

                ctx.clearRect(0, 0, width, height);

                ctx.beginPath();
                ctx.moveTo(0, height - (((elevations[0] - minEle) / eleRange) * (height - padding * 2) + padding));
                for (let i = 1; i < state.gpxData.length; i++) {
                    const segment = state.gpxData[i];
                    const x = (segment.startDistance / state.totalDistance) * width;
                    const y = height - (((segment.ele - minEle) / eleRange) * (height - padding * 2) + padding);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();
                
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(45, 212, 191, 0.5)');
                gradient.addColorStop(1, 'rgba(34, 41, 57, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(0, height - (((elevations[0] - minEle) / eleRange) * (height - padding * 2) + padding));
                 for (let i = 1; i < state.gpxData.length; i++) {
                    const segment = state.gpxData[i];
                    const x = (segment.startDistance / state.totalDistance) * width;
                    const y = height - (((segment.ele - minEle) / eleRange) * (height - padding * 2) + padding);
                    ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#2dd4bf';
                ctx.lineWidth = 2;
                ctx.stroke();
            },
            updateRacerDots() {
                if (!state.totalDistance || state.totalDistance === 0) return;
                
                Object.values(state.racers).forEach(racer => {
                    let dot = document.getElementById(`dot-${racer.id}`);
                    if (!dot) {
                        dot = document.createElement('div');
                        dot.id = `dot-${racer.id}`;
                        dot.className = 'race-dot absolute w-3 h-3 rounded-full border-2';
                        dot.style.transform = 'translateY(-50%)';
                        DOMElements.courseProfileContainer.appendChild(dot);
                    }
                    
                    const percentComplete = (racer.distance / state.totalDistance);
                    const currentPos = state.totalDistance * percentComplete;
                    let segmentIndex = state.gpxData.findIndex(p => p.startDistance <= currentPos && (p.startDistance + p.distance) > currentPos);
                    
                    if (segmentIndex === -1 && state.gpxData.length > 1) {
                        segmentIndex = state.gpxData.length - 2;
                    } else if (segmentIndex === -1 || !state.gpxData[segmentIndex + 1]) {
                         segmentIndex = state.gpxData.length -2;
                         if (segmentIndex < 0) return; // Not enough data to draw dot
                    }

                    const p1 = state.gpxData[segmentIndex];
                    const p2 = state.gpxData[segmentIndex + 1];

                    if (p1 && p2) {
                        const segmentDist = p2.startDistance - p1.startDistance;
                        const distIntoSegment = currentPos - p1.startDistance;
                        const percentIntoSegment = segmentDist > 0 ? distIntoSegment / segmentDist : 0;
                        
                        const interpolatedEle = p1.ele + (p2.ele - p1.ele) * percentIntoSegment;

                        const elevations = state.gpxData.map(p => p.ele);
                        const maxEle = Math.max(...elevations);
                        const minEle = Math.min(...elevations);
                        const eleRange = maxEle - minEle === 0 ? 1 : maxEle - minEle;
                        const padding = 20;

                        const rect = DOMElements.courseProfileCanvas.getBoundingClientRect();
                        const yPercent = 1 - ((interpolatedEle - minEle) / eleRange);
                        const topPx = yPercent * (rect.height - padding * 2) + padding;

                        dot.style.top = `${topPx}px`;
                    }

                    const isSelf = racer.id === state.userId;
                    dot.style.backgroundColor = isSelf ? '#2dd4bf' : '#f87171';
                    dot.style.borderColor = isSelf ? '#fff' : '#000';
                    dot.style.zIndex = isSelf ? '10' : '5';
                    dot.style.left = `calc(${percentComplete * 100}% - 6px)`;
                });
            },
            showShareLink(raceId) {
                const baseUrl = window.location.href.split('?')[0];
                const url = `${baseUrl}?raceId=${raceId}`;
                DOMElements.shareLinkInput.value = url;
                DOMElements.shareLinkSection.classList.remove('hidden');
            },
            copyShareLink() {
                DOMElements.shareLinkInput.select();
                document.execCommand('copy');
                DOMElements.copyLinkBtn.textContent = 'Copied!';
                setTimeout(() => { DOMElements.copyLinkBtn.textContent = 'Copy'; }, 2000);
            }
        };

        // --- MAIN GAME LOOP ---
        let lastUpdateTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = (now - lastUpdateTime) / 1000; // seconds
            lastUpdateTime = now;

            if (state.trainer.connected && state.raceId && state.gpxData) {
                 // Calculate speed based on power
                const speedMps = PhysicsController.calculateSpeedMps(state.power, state.gradient, state.riderWeightLbs);
                state.speed = speedMps * 2.23694; // Convert m/s to mph
                UIController.updateSpeed();

                // Find current segment in the GPX route
                let currentSegment = state.gpxData.find(s => state.distanceCovered >= s.startDistance && state.distanceCovered < (s.startDistance + s.distance));
                if (currentSegment) {
                    const newGradient = currentSegment.gradient;
                    if (Math.abs(newGradient - state.gradient) > 0.1) {
                         state.gradient = newGradient;
                         BluetoothController.setGradient(state.gradient);
                         UIController.updateGradient();
                    }
                }
                
                // Only accumulate distance if the race has started
                if (state.raceStarted && state.speed > 0) {
                    const distanceThisFrame = Math.min(0.1, (state.speed / 3600) * deltaTime); // distance in miles
                    state.distanceCovered = Math.min(state.totalDistance, state.distanceCovered + distanceThisFrame);
                    UIController.updateDistance();
                }
                
                // Always update player state for live leaderboard/dots
                FirebaseController.updatePlayerState();
            }

            requestAnimationFrame(gameLoop);
        }

        // --- INITIALIZATION ---
        function init() {
            FirebaseController.init();
            UIController.init();
            gameLoop();
        }

        init();
    </script>
</body>
</html>


